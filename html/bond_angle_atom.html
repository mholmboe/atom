<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>bond_angle_atom.m</title>
<meta name="generator" content="MATLAB 24.2">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2025-05-23">
<meta name="DC.source" content="bond_angle_atom.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h1>bond_angle_atom.m</h1>
<!--introduction-->
<div>
<ul>
<li>This function tries to find all bonds and angles of the atom struct</li>
<li>One optional argument like 'more' will give more bond info.</li>
<li>Line 142 can turn on/off bonds between same types of atoms</li>
<li>atom is the atom struct</li>
<li>Box_dim is the box dimension vector</li>
</ul>
</div>
<!--/introduction-->
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#1">Version</a>
</li>
<li>
<a href="#2">Contact</a>
</li>
<li>
<a href="#3">Examples</a>
</li>
</ul>
</div>
<h2 id="1">Version</h2>
<p>3.00</p>
<h2 id="2">Contact</h2>
<p>Please report problems/bugs to <a href="mailto:michael.holmboe@umu.se">michael.holmboe@umu.se</a>
</p>
<h2 id="3">Examples</h2>
<div>
<ol>
<li>atom=bond_angle_atom(atom,Box_dim) % Basic input arguments</li>
<li>atom=bond_angle_atom(atom) % When PBC is not important</li>
<li>atom=bond_angle_atom(atom,Box_dim,1.25,2.25) % Allows setting the rmaxshort and rmaxlong</li>
<li>atom=bond_angle_atom(atom,Box_dim,1.25,2.25,'more') % Will write more info to the calling workspace</li>
</ol>
</div>
<pre class="codeinput">
<span class="keyword">function</span> atom=bond_angle_atom(atom,varargin)
</pre>
<p>tic</p>
<pre class="codeinput">
<span class="keyword">if</span> nargin&lt;=4
    <span class="keyword">if</span> nargin&lt;4
        <span class="keyword">if</span> nargin==1
            Box_dim=1e6*[1 1 1]; <span class="comment">% Dummy Box_dim, when the PBC is not important</span>
        <span class="keyword">else</span>
            Box_dim=varargin{1};
        <span class="keyword">end</span>
        rmaxshort=1.25;
        rmaxlong=2.25;
    <span class="keyword">else</span>
        Box_dim=varargin{1};
        rmaxshort=varargin{2};
        rmaxlong=varargin{3};
    <span class="keyword">end</span>
<span class="keyword">elseif</span> nargin&gt;4
    Box_dim=varargin{1};
    rmaxshort=varargin{2};
    rmaxlong=varargin{3};
<span class="keyword">end</span>

nAtoms=size(atom,2);
<span class="comment">% max_short_dist=1.2;</span>
<span class="comment">% max_long_dist=2.3;</span>

XYZ_labels=[atom.type]';
XYZ_data=single([[atom.x]' [atom.y]' [atom.z]']); <span class="comment">% use of single instead of double</span>

lx=Box_dim(1);ly=Box_dim(2);lz=Box_dim(3);
<span class="keyword">if</span> length(Box_dim) &gt; 3
    xy=Box_dim(6);xz=Box_dim(8);yz=Box_dim(9);
<span class="keyword">else</span>
    xy=0;xz=0;yz=0;
<span class="keyword">end</span>

disp(<span class="string">'Calculating distances'</span>)

close_count=1;
Bond_index=single(zeros(4*size(XYZ_data,1),3)); <span class="comment">% use of single instead of double</span>
Angle_index=single(zeros(4*size(XYZ_data,1),4)); <span class="comment">% use of single instead of double</span>
dist_matrix=single(zeros(nAtoms,nAtoms)); <span class="comment">% use of single instead of double</span>
<span class="comment">% dist_matrix = dist_matrix_atom(atom,Box_dim); % Do this if you want to calc dist_matrix_atom first</span>
b=1;a=1; overlap_index=[];
<span class="keyword">for</span> i = 1:size(XYZ_data,1)

    <span class="comment">%     disp('Setting max_neigh_distance to... ')</span>
    <span class="comment">%     max_neigh_distance = max_long_dist %2.25; % Set large max_neigh_distance so that we can find Si-O-H and Al-OH2 bonds %max_long_dist;%2.3</span>
    <span class="comment">%     disp('If you have problems, change back to 2.25 on line 43 in bond_angle_atom()')</span>
    <span class="comment">%     max_neigh_distance = max_long_dist; % Change to 2.25 if adding edge bonds</span>

    <span class="keyword">if</span> strcmpi(strtrim(XYZ_labels(i)),<span class="string">'Oalhh'</span>) || strcmp(strtrim(XYZ_labels(i)),<span class="string">'Osih'</span>)
        <span class="keyword">if</span> rmaxlong &lt; 2.25
            max_neigh_distance = 2.25;
        <span class="keyword">else</span>
            max_neigh_distance = rmaxlong;
        <span class="keyword">end</span>
    <span class="keyword">else</span>
        max_neigh_distance = rmaxlong;
    <span class="keyword">end</span>
    <span class="comment">%                 disp('Looking for M-O-H bonds')</span>

    <span class="keyword">if</span> length(Box_dim)&gt;3
        <span class="comment">%Calculate Distance Components for triclic cell</span>
        rz = XYZ_data(i,3) - XYZ_data(:,3);
        ry = XYZ_data(i,2) - XYZ_data(:,2);
        rx = XYZ_data(i,1) - XYZ_data(:,1);

        z_gt_ind=find(rz &gt; lz/2); z_lt_ind=find(rz &lt; - lz/2);
        rz(z_gt_ind) = rz(z_gt_ind) - lz;
        rz(z_lt_ind) = rz(z_lt_ind) + lz;
        rx(z_gt_ind) = rx(z_gt_ind) - xz;
        rx(z_lt_ind) = rx(z_lt_ind) + xz;
        ry(z_gt_ind) = ry(z_gt_ind) - yz;
        ry(z_lt_ind) = ry(z_lt_ind) + yz;

        y_gt_ind=find(ry &gt; ly/2); y_lt_ind=find(ry &lt; - ly/2);
        ry(y_gt_ind) = ry(y_gt_ind) - ly;
        ry(y_lt_ind) = ry(y_lt_ind) + ly;
        rx(y_gt_ind) = rx(y_gt_ind) - xy;
        rx(y_lt_ind) = rx(y_lt_ind) + xy;

        x_gt_ind=find(rx &gt; lx/2); x_lt_ind=find(rx &lt; - lx/2);
        rx(x_gt_ind) = rx(x_gt_ind) - lx;
        rx(x_lt_ind) = rx(x_lt_ind) + lx;
    <span class="keyword">else</span>
        <span class="comment">%Calculate Distance Components for ortogonal cell</span>

        rz = XYZ_data(i,3) - XYZ_data(:,3);
        z_gt_ind=find(rz &gt; lz/2); z_lt_ind=find(rz &lt; - lz/2);
        rz(z_gt_ind) = rz(z_gt_ind) - lz;
        rz(z_lt_ind) = rz(z_lt_ind) + lz;

        ry = XYZ_data(i,2) - XYZ_data(:,2);
        y_gt_ind=find(ry &gt; ly/2); y_lt_ind=find(ry &lt; - ly/2);
        ry(y_gt_ind) = ry(y_gt_ind) - ly;
        ry(y_lt_ind) = ry(y_lt_ind) + ly;

        rx = XYZ_data(i,1) - XYZ_data(:,1);
        x_gt_ind=find(rx &gt; lx/2); x_lt_ind=find(rx &lt; - lx/2);
        rx(x_gt_ind) = rx(x_gt_ind) - lx;
        rx(x_lt_ind) = rx(x_lt_ind) + lx;

    <span class="keyword">end</span>

    r = sqrt( rx(:,1).^2 + ry(:,1).^2 + rz(:,1).^2 ); <span class="comment">% distance calc.</span>
    bond_in=intersect(find(r &gt; 0), find(r &lt; max_neigh_distance));
    dist_matrix(:,i)=r;


    <span class="comment">% Else if we already called dist_matrix_atom...</span>
    <span class="comment">%     r = dist_matrix(:,i);</span>
    <span class="comment">%     rx= X_dist(:,i);</span>
    <span class="comment">%     ry= Y_dist(:,i);</span>
    <span class="comment">%     rz= Z_dist(:,i);</span>
    <span class="comment">%     bond_in=intersect(find(r &gt; 0), find(r &lt; max_neigh_distance));</span>
    <span class="comment">%</span>

    n=1;
    Neigh_ind=zeros(12,1);Neigh_vec=zeros(12,3);
    <span class="keyword">for</span> j=1:length(bond_in)
        <span class="keyword">if</span> [atom(i).molid]==[atom(bond_in(j)).molid] &amp;&amp; (strncmpi([atom(i).type],[atom(bond_in(j)).type],1) == 0) <span class="comment">% This checks for bonds between equal element types</span>
            <span class="comment">% Original, uncomment this section</span>
            <span class="comment">% max_distance = max_short_dist;</span>
            <span class="comment">% Only test</span>
            <span class="keyword">if</span> strncmpi(strtrim(XYZ_labels(i)),<span class="string">'H'</span>,1) || strncmpi(strtrim(XYZ_labels(bond_in(j))),<span class="string">'H'</span>,1)
                max_distance = rmaxshort;
            <span class="keyword">elseif</span> strcmpi(strtrim(XYZ_labels(i)),<span class="string">'Oalhh'</span>) || strcmp(strtrim(XYZ_labels(i)),<span class="string">'Osih'</span>)
                <span class="keyword">if</span> rmaxlong &lt; 2.25
                    max_distance = 2.25;
                <span class="keyword">else</span>
                    max_distance = rmaxlong;
                <span class="keyword">end</span>
                <span class="comment">%                 disp('Looking for M-O-H bonds')</span>
            <span class="keyword">else</span>
                max_distance = rmaxlong;
            <span class="keyword">end</span>

            <span class="keyword">if</span> r(bond_in(j)) &lt; 0.6
                disp(<span class="string">'Atoms too close!!!'</span>)
                r(bond_in(j))
                [i,bond_in(j)]
                XYZ_labels(i)
                XYZ_labels(bond_in(j))
                XYZ_data(i,:)
                XYZ_data(bond_in(j),:)
                overlap_index=[overlap_index; {i bond_in(j) r(bond_in(j)) XYZ_labels(i) XYZ_labels(bond_in(j)) XYZ_data(i,:) XYZ_data(bond_in(j),:)}];
            <span class="keyword">elseif</span> r(bond_in(j)) &gt; max_distance &amp;&amp; r(bond_in(j)) &lt; 1.25
                disp(<span class="string">'Atoms pretty close...'</span>)
                r(bond_in(j))
                [i,bond_in(j)]
                XYZ_labels(i)
                XYZ_labels(bond_in(j))
                XYZ_data(i,:)
                XYZ_data(bond_in(j),:)
                close_count=close_count+1;
                overlap_index=[overlap_index; {i bond_in(j) r(bond_in(j)) XYZ_labels(i) XYZ_labels(bond_in(j)) XYZ_data(i,:) XYZ_data(bond_in(j),:)}];
            <span class="keyword">end</span>

            <span class="keyword">if</span> r(bond_in(j)) &gt; max_distance/3 &amp;&amp; r(bond_in(j)) &lt; max_distance <span class="comment">%strncmpi(XYZ_labels(i),strtrim(XYZ_labels(j)),1) == 0;</span>
                <span class="keyword">if</span> strncmpi(strtrim(XYZ_labels(i)),{<span class="string">'OW'</span>},2)<span class="comment">% || strncmpi(strtrim(XYZ_labels(bond_in(j))),{'OW'},2); % &lt; bond_in(j) &amp;&amp; ismember(XYZ_labels(i),{'Ow','Hw','OW','HW','HW1','HW2'}) &gt; 0;</span>
                    <span class="keyword">if</span> bond_in(j) &gt; i &amp;&amp; bond_in(j) &lt; i+3 <span class="comment">%strncmpi(strtrim(XYZ_labels(i)),{'Ow'},2) &amp;&amp; bond_in(j) &gt; i &amp;&amp; bond_in(j) &lt; i+3;</span>
                        Bond_index(b,1)= min([i bond_in(j)]);
                        Bond_index(b,2)= max([i bond_in(j)]);
                        Bond_index(b,3)= r(bond_in(j));
                        b=b+1;
                        <span class="keyword">if</span> r(bond_in(j)) &lt; rmaxshort <span class="comment">% This should always be true right?</span>
                            Neigh_ind(n,1)= bond_in(j);
                            Neigh_vec(n,1:3) = -[rx(bond_in(j)) ry(bond_in(j)) rz(bond_in(j))];
                            n=n+1;
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">elseif</span> strncmpi(strtrim(XYZ_labels(i)),{<span class="string">'HW'</span>},2)
                    <span class="comment">% disp('HW')</span>
                <span class="keyword">elseif</span> strncmpi(strtrim(XYZ_labels(i)),{<span class="string">'H'</span>},1) &amp;&amp; strncmpi(strtrim(XYZ_labels(bond_in(j))),{<span class="string">'H'</span>},1)
                    <span class="comment">%                     disp('disallowed a H-H bond')</span>
                <span class="keyword">elseif</span> ismember({<span class="string">'H'</span>},[XYZ_labels(i) XYZ_labels(bond_in(j))]) &gt; 0 || ismember({<span class="string">'Oalhh'</span>},[XYZ_labels(i) XYZ_labels(bond_in(j))]) &gt; 0 || ismember({<span class="string">'Osih'</span>},[XYZ_labels(i) XYZ_labels(j)]) &gt; 0 &amp;&amp; ismember(XYZ_labels(bond_in(j)),{<span class="string">'Ow'</span>,<span class="string">'Hw'</span>,<span class="string">'OW'</span>,<span class="string">'HW'</span>,<span class="string">'HW1'</span>,<span class="string">'HW2'</span>}) == 0
                    Bond_index(b,1)= min([i bond_in(j)]);
                    Bond_index(b,2)= max([i bond_in(j)]);
                    Bond_index(b,3)= r(bond_in(j));
                    b=b+1;
                    <span class="keyword">if</span> r(bond_in(j)) &lt; max_distance <span class="comment">% This should always be true right?</span>
                        Neigh_ind(n,1)= bond_in(j);
                        Neigh_vec(n,1:3) = -[rx(bond_in(j)) ry(bond_in(j)) rz(bond_in(j))];
                        n=n+1;
                    <span class="keyword">end</span>
                <span class="keyword">elseif</span> ~strncmpi(strtrim(XYZ_labels(i)),{<span class="string">'OW'</span>},2) || ~strncmpi(strtrim(XYZ_labels(i)),{<span class="string">'HW'</span>},2)
                    <span class="keyword">if</span> bond_in(j) &lt; i
                        Bond_index(b,1)= min([i bond_in(j)]);
                        Bond_index(b,2)= max([i bond_in(j)]);
                        Bond_index(b,3)= r(bond_in(j));
                        b=b+1;
                    <span class="keyword">end</span>
                    <span class="keyword">if</span> r(bond_in(j)) &lt; max_distance <span class="comment">% This should always be true right?</span>
                        Neigh_ind(n,1)= bond_in(j);
                        Neigh_vec(n,1:3) = -[rx(bond_in(j)) ry(bond_in(j)) rz(bond_in(j))];
                        n=n+1;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>

        <span class="keyword">end</span> <span class="comment">% test</span>

        Neigh_ind(~any(Neigh_ind,2),:) = [];
        Neigh_vec(~any(Neigh_vec,2),:) = [];

        <span class="keyword">for</span> v=1:size(Neigh_ind,1)
            <span class="keyword">for</span> w=1:size(Neigh_ind,1) <span class="comment">% From v or from 1?</span>
                angle=rad2deg(atan2(norm(cross(Neigh_vec(v,:),Neigh_vec(w,:))),dot(Neigh_vec(v,:),Neigh_vec(w,:))));
                <span class="keyword">if</span> angle &gt; 0 &amp;&amp; angle &lt;= 180 <span class="comment">% Do we need this??</span>
                    <span class="keyword">if</span> v &lt; w
                        Angle_index(a,1)= Neigh_ind(v,1);
                        Angle_index(a,2)= i;
                        Angle_index(a,3)= Neigh_ind(w,1);
                        Angle_index(a,4)= angle;
                        Angle_index(a,5:7)= Neigh_vec(v,:);
                        Angle_index(a,8:10)= Neigh_vec(w,:);
                        a=a+1;
                    <span class="keyword">else</span>
                        Angle_index(a,1)= Neigh_ind(w,1);
                        Angle_index(a,2)= i;
                        Angle_index(a,3)= Neigh_ind(v,1);
                        Angle_index(a,4)= angle;
                        Angle_index(a,5:7)= Neigh_vec(w,:);
                        Angle_index(a,8:10)= Neigh_vec(v,:);
                        a=a+1;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> mod(i,1000)==1
        <span class="keyword">if</span> i-1&gt;0
            i-1
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
i

[Y,I]=sort(Bond_index(:,1));
Bond_index=Bond_index(I,:);
Bond_index = unique(Bond_index,<span class="string">'rows'</span>,<span class="string">'stable'</span>);

[Y,I]=sort(Angle_index(:,1));
Angle_index=Angle_index(I,:);
Angle_index = unique(Angle_index,<span class="string">'rows'</span>,<span class="string">'stable'</span>);

[Y,I]=sort(Angle_index(:,2));
Angle_index=Angle_index(I,:);
Angle_index = unique(Angle_index,<span class="string">'rows'</span>,<span class="string">'stable'</span>);

overlap_index=overlap_index(1:size(overlap_index,1)/2,:);
<span class="comment">% [Y,I]=sort(cell2mat(overlap_index(:,2)));</span>
<span class="comment">% overlap_index=overlap_index(I,:);</span>
<span class="comment">% overlap_index = unique(overlap_index,'rows','stable');</span>

Bond_index(~any(Bond_index,2),:) = [];
Angle_index(~any(Angle_index,2),:) = [];
<span class="comment">% overlap_index(~any(overlap_index,2),:) = [];</span>

nBonds=size(Bond_index,1);
nAngles=size(Angle_index,1);

<span class="keyword">try</span>
    <span class="comment">% Set a cutoff vector</span>
    rmax=repmat(max_neigh_distance,nAtoms,1);
    <span class="comment">% Reduce the cutoff vector for H - X</span>
    rmax(strncmpi(strtrim(XYZ_labels),<span class="string">'H'</span>,1))=rmaxshort; <span class="comment">%1.25;</span>
    <span class="keyword">for</span> i=1:size(atom,2)
        Neigh_ind=intersect(find(dist_matrix(:,i)&gt;0),find(dist_matrix(:,i)&lt;rmax(i)));<span class="comment">%radius_ion([atom.type])));</span>
        Neigh_dist=dist_matrix(Neigh_ind,i);
        atom(i).neigh.type = [atom(Neigh_ind).type]';
        atom(i).neigh.index = Neigh_ind;
        atom(i).neigh.dist = Neigh_dist;
        atom(i).neigh.coords = [[atom(Neigh_ind).x]' [atom(Neigh_ind).y]' [atom(Neigh_ind).z]']; <span class="comment">% PBC NOT TAKEN INTO ACCOUNT!!!</span>
        atom(i).bond.type = [];
        atom(i).bond.index = [];
        atom(i).bond.dist = [];
        atom(i).angle.type = [];
        atom(i).angle.index = [];
        atom(i).angle.angle = [];
        atom(i).angle.vec1 = [];
        atom(i).angle.vec2 = [];

        <span class="keyword">if</span> ismember(i,Bond_index(:,1:2))
            [A,B]=find(Bond_index(:,1:2)==i);
            atom(i).bond.type = 1;
            atom(i).bond.index = Bond_index(A,1:2);
            atom(i).bond.dist = Bond_index(A,3);
            <span class="keyword">if</span> ismember(i,Angle_index(:,1:3))
                <span class="comment">%                 [C,D]=find(Angle_index(:,1:3)==i);</span>
                [C,D]=find(Angle_index(:,2)==i);
                atom(i).angle.type = 1;
                atom(i).angle.index = Angle_index(C,1:3);
                atom(i).angle.angle = Angle_index(C,4);
                atom(i).angle.vec1 = Angle_index(C,5:7);
                atom(i).angle.vec2 = Angle_index(C,8:10);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">if</span> mod(i,1000)==1
            <span class="keyword">if</span> i-1&gt;0
                i-1
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">catch</span>
    disp(<span class="string">'Could not assign either bonds, neighbours or angles...'</span>)
<span class="keyword">end</span>
<span class="keyword">if</span> nargin &gt; 4 <span class="comment">%% This will print a whole lot more info to the calling workspace</span>
    <span class="comment">%%%%%%%%%%</span>

    Atom_labels=unique([atom.type]);
    <span class="keyword">for</span> i=1:length(Atom_labels)
        label_ind=find(strcmpi([atom.type],Atom_labels(i)));
        Tot_dist=[];Tot_CN=[];Tot_type=[];Tot_index=[];Tot_angleindex=[];Tot_bondindex=[];Tot_neighindex=[];Tot_coords=[];Tot_bonds=[];Tot_angles=[];
        <span class="keyword">for</span> j=label_ind
            <span class="keyword">if</span> numel([atom(j).neigh])&gt;0
                Tot_index=[Tot_index; repmat(j,numel([atom(j).neigh.index]),1)];
                Tot_dist=[Tot_dist; [atom(j).neigh.dist]];
                CN_temp=numel([atom(j).neigh.dist]);
                Tot_CN=[Tot_CN;CN_temp*ones(CN_temp,1)];
                Tot_type=[Tot_type; [atom(j).neigh.type]];
                Tot_neighindex=[Tot_neighindex; [atom(j).neigh.index]];
                Tot_coords=[Tot_coords; [atom(j).neigh.coords]];
            <span class="keyword">end</span>

            <span class="keyword">if</span> numel([atom(j).bond])&gt;0
                Tot_bondindex=[Tot_bondindex; [atom(j).bond.index]];
                Tot_bonds=[Tot_bonds; [atom(j).bond.dist]];
            <span class="keyword">end</span>
            <span class="keyword">if</span> numel([atom(j).angle])&gt;0
                Tot_angleindex=[Tot_angleindex; [atom(j).angle.index]];
                Tot_angles=[Tot_angles; [atom(j).angle.angle] CN_temp*ones(numel([atom(j).angle.angle]),1)]; <span class="comment">%</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">try</span>
            assignin(<span class="string">'caller'</span>,strcat(char(Atom_labels(i)),<span class="string">'_dist'</span>)',[num2cell(Tot_index,2) num2cell(Tot_neighindex,2) Tot_type num2cell(Tot_dist,2) num2cell(Tot_CN,2)]);
            assignin(<span class="string">'caller'</span>,strcat(char(Atom_labels(i)),<span class="string">'_coords'</span>)',[[atom(Tot_neighindex).x]' [atom(Tot_neighindex).y]' [atom(Tot_neighindex).z]']);
            assignin(<span class="string">'caller'</span>,strcat(char(Atom_labels(i)),<span class="string">'_bonds'</span>)',[Tot_bondindex Tot_bonds]);
            assignin(<span class="string">'caller'</span>,strcat(char(Atom_labels(i)),<span class="string">'_angles'</span>)',[Tot_angleindex Tot_angles]);
            assignin(<span class="string">'caller'</span>,strcat(char(Atom_labels(i)),<span class="string">'_atom'</span>)',atom(ismember([atom.type],Atom_labels(i))));

            assignin(<span class="string">'base'</span>,strcat(char(Atom_labels(i)),<span class="string">'_dist'</span>)',[num2cell(Tot_index,2) num2cell(Tot_neighindex,2) Tot_type num2cell(Tot_dist,2) num2cell(Tot_CN,2)]);
            assignin(<span class="string">'base'</span>,strcat(char(Atom_labels(i)),<span class="string">'_coords'</span>)',[[atom(Tot_neighindex).x]' [atom(Tot_neighindex).y]' [atom(Tot_neighindex).z]']);
            assignin(<span class="string">'base'</span>,strcat(char(Atom_labels(i)),<span class="string">'_bonds'</span>)',[Tot_bondindex Tot_bonds]);
            assignin(<span class="string">'base'</span>,strcat(char(Atom_labels(i)),<span class="string">'_angles'</span>)',[Tot_angleindex Tot_angles]);
            assignin(<span class="string">'base'</span>,strcat(char(Atom_labels(i)),<span class="string">'_atom'</span>)',atom(ismember([atom.type],Atom_labels(i))));
        <span class="keyword">catch</span>
            assignin(<span class="string">'base'</span>,strcat(char(Atom_labels(i)),<span class="string">'_dist'</span>)',[num2cell(Tot_index,2) num2cell(Tot_neighindex,2) Tot_type num2cell(Tot_dist,2) num2cell(Tot_CN,2)]);
            assignin(<span class="string">'base'</span>,strcat(char(Atom_labels(i)),<span class="string">'_coords'</span>)',[[atom(Tot_neighindex).x]' [atom(Tot_neighindex).y]' [atom(Tot_neighindex).z]']);
            assignin(<span class="string">'base'</span>,strcat(char(Atom_labels(i)),<span class="string">'_bonds'</span>)',[Tot_bondindex Tot_bonds]);
            assignin(<span class="string">'base'</span>,strcat(char(Atom_labels(i)),<span class="string">'_angles'</span>)',[Tot_angleindex Tot_angles]);
            assignin(<span class="string">'base'</span>,strcat(char(Atom_labels(i)),<span class="string">'_atom'</span>)',atom(ismember([atom.type],Atom_labels(i))));
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">try</span>
        <span class="keyword">for</span> i=1:size(Bond_index,1)
            Bondstruct(i).types=strcat(atom(Bond_index(i,1)).type,atom(Bond_index(i,2)).type);
            Bondstruct(i).dist=Bond_index(i,3);
        <span class="keyword">end</span>
        Bondtypes=unique([Bondstruct.types]);

        <span class="keyword">for</span> i=1:size(Bondtypes,2)
            ind=strcmp([Bondstruct.types],Bondtypes(i));
            Ave_Bonds(i).types=Bondtypes(i);
            Ave_Bonds(i).dist=mean([Bondstruct(ind).dist]);
            Ave_Bonds(i).dist_std=std([Bondstruct(ind).dist]);
        <span class="keyword">end</span>

        <span class="keyword">for</span> i=1:size(Angle_index,1)
            Anglestruct(i).types=strcat(atom(Angle_index(i,1)).type,atom(Angle_index(i,2)).type,atom(Angle_index(i,3)).type);
            Anglestruct(i).angle=Angle_index(i,4);
        <span class="keyword">end</span>
        Angletypes=unique([Anglestruct.types]);

        <span class="keyword">for</span> i=1:size(Angletypes,2)
            ind=strcmp([Anglestruct.types],Angletypes(i));
            Ave_Angles(i).types=Angletypes(i);
            Ave_Angles(i).angle=mean([Anglestruct(ind).angle]);
            Ave_Angles(i).angle_std=std([Anglestruct(ind).angle]);
        <span class="keyword">end</span>

        assignin(<span class="string">'caller'</span>,<span class="string">'Ave_Bonds'</span>,Ave_Bonds);
        assignin(<span class="string">'caller'</span>,<span class="string">'Ave_Angles'</span>,Ave_Angles);

    <span class="keyword">catch</span>
        disp(<span class="string">'Could not calculate average bonds and/or angles'</span>)
    <span class="keyword">end</span>

<span class="keyword">end</span>

[Y,I]=sort(Bond_index(:,2));
Bond_index=Bond_index(I,:);
Bond_index = unique(Bond_index,<span class="string">'rows'</span>,<span class="string">'stable'</span>);

[Y,I]=sort(Bond_index(:,1));
Bond_index=Bond_index(I,:);
Bond_index = unique(Bond_index,<span class="string">'rows'</span>,<span class="string">'stable'</span>);

[Y,I]=sort(Angle_index(:,1));
Angle_index=Angle_index(I,:);
Angle_index = unique(Angle_index,<span class="string">'rows'</span>,<span class="string">'stable'</span>);

[Y,I]=sort(Angle_index(:,2));
Angle_index=Angle_index(I,:);
Angle_index = unique(Angle_index,<span class="string">'rows'</span>,<span class="string">'stable'</span>);

atom=order_attributes(atom);

<span class="keyword">try</span>
    assignin(<span class="string">'caller'</span>,<span class="string">'dist_matrix'</span>,dist_matrix);
    assignin(<span class="string">'caller'</span>,<span class="string">'overlap_index'</span>,overlap_index);
    assignin(<span class="string">'caller'</span>,<span class="string">'Bond_index'</span>,Bond_index);
    assignin(<span class="string">'caller'</span>,<span class="string">'Angle_index'</span>,Angle_index);
    assignin(<span class="string">'caller'</span>,<span class="string">'nBonds'</span>,nBonds);
    assignin(<span class="string">'caller'</span>,<span class="string">'nAngles'</span>,nAngles);
<span class="keyword">catch</span>
    assignin(<span class="string">'base'</span>,<span class="string">'dist_matrix'</span>,dist_matrix);
    assignin(<span class="string">'base'</span>,<span class="string">'overlap_index'</span>,overlap_index);
    assignin(<span class="string">'base'</span>,<span class="string">'Bond_index'</span>,Bond_index);
    assignin(<span class="string">'base'</span>,<span class="string">'Angle_index'</span>,Angle_index);
    assignin(<span class="string">'base'</span>,<span class="string">'nBonds'</span>,nBonds);
    assignin(<span class="string">'base'</span>,<span class="string">'nAngles'</span>,nAngles);
<span class="keyword">end</span>
</pre>
<pre class="codeinput">
<span class="comment">% toc</span>
</pre>
<p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2024b</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
%% bond_angle_atom.m
% * This function tries to find all bonds and angles of the atom struct
% * One optional argument like 'more' will give more bond info.
% * Line 142 can turn on/off bonds between same types of atoms
% * atom is the atom struct
% * Box_dim is the box dimension vector
%
%% Version
% 3.00
%
%% Contact
% Please report problems/bugs to michael.holmboe@umu.se
%
%% Examples
% # atom=bond_angle_atom(atom,Box_dim) % Basic input arguments
% # atom=bond_angle_atom(atom) % When PBC is not important
% # atom=bond_angle_atom(atom,Box_dim,1.25,2.25) % Allows setting the rmaxshort and rmaxlong
% # atom=bond_angle_atom(atom,Box_dim,1.25,2.25,'more') % Will write more info to the calling workspace
%

function atom=bond_angle_atom(atom,varargin)
%%
% tic

if nargin<=4
    if nargin<4
        if nargin==1
            Box_dim=1e6*[1 1 1]; % Dummy Box_dim, when the PBC is not important
        else
            Box_dim=varargin{1};
        end
        rmaxshort=1.25;
        rmaxlong=2.25;
    else
        Box_dim=varargin{1};
        rmaxshort=varargin{2};
        rmaxlong=varargin{3};
    end
elseif nargin>4
    Box_dim=varargin{1};
    rmaxshort=varargin{2};
    rmaxlong=varargin{3};
end

nAtoms=size(atom,2);
% max_short_dist=1.2;
% max_long_dist=2.3;

XYZ_labels=[atom.type]';
XYZ_data=single([[atom.x]' [atom.y]' [atom.z]']); % use of single instead of double

lx=Box_dim(1);ly=Box_dim(2);lz=Box_dim(3);
if length(Box_dim) > 3
    xy=Box_dim(6);xz=Box_dim(8);yz=Box_dim(9);
else
    xy=0;xz=0;yz=0;
end

disp('Calculating distances')

close_count=1;
Bond_index=single(zeros(4*size(XYZ_data,1),3)); % use of single instead of double
Angle_index=single(zeros(4*size(XYZ_data,1),4)); % use of single instead of double
dist_matrix=single(zeros(nAtoms,nAtoms)); % use of single instead of double
% dist_matrix = dist_matrix_atom(atom,Box_dim); % Do this if you want to calc dist_matrix_atom first
b=1;a=1; overlap_index=[];
for i = 1:size(XYZ_data,1)

    %     disp('Setting max_neigh_distance to... ')
    %     max_neigh_distance = max_long_dist %2.25; % Set large max_neigh_distance so that we can find Si-O-H and Al-OH2 bonds %max_long_dist;%2.3
    %     disp('If you have problems, change back to 2.25 on line 43 in bond_angle_atom()')
    %     max_neigh_distance = max_long_dist; % Change to 2.25 if adding edge bonds

    if strcmpi(strtrim(XYZ_labels(i)),'Oalhh') || strcmp(strtrim(XYZ_labels(i)),'Osih')
        if rmaxlong < 2.25
            max_neigh_distance = 2.25;
        else
            max_neigh_distance = rmaxlong;
        end
    else
        max_neigh_distance = rmaxlong;
    end
    %                 disp('Looking for M-O-H bonds')

    if length(Box_dim)>3
        %Calculate Distance Components for triclic cell
        rz = XYZ_data(i,3) - XYZ_data(:,3);
        ry = XYZ_data(i,2) - XYZ_data(:,2);
        rx = XYZ_data(i,1) - XYZ_data(:,1);

        z_gt_ind=find(rz > lz/2); z_lt_ind=find(rz < - lz/2);
        rz(z_gt_ind) = rz(z_gt_ind) - lz;
        rz(z_lt_ind) = rz(z_lt_ind) + lz;
        rx(z_gt_ind) = rx(z_gt_ind) - xz;
        rx(z_lt_ind) = rx(z_lt_ind) + xz;
        ry(z_gt_ind) = ry(z_gt_ind) - yz;
        ry(z_lt_ind) = ry(z_lt_ind) + yz;

        y_gt_ind=find(ry > ly/2); y_lt_ind=find(ry < - ly/2);
        ry(y_gt_ind) = ry(y_gt_ind) - ly;
        ry(y_lt_ind) = ry(y_lt_ind) + ly;
        rx(y_gt_ind) = rx(y_gt_ind) - xy;
        rx(y_lt_ind) = rx(y_lt_ind) + xy;

        x_gt_ind=find(rx > lx/2); x_lt_ind=find(rx < - lx/2);
        rx(x_gt_ind) = rx(x_gt_ind) - lx;
        rx(x_lt_ind) = rx(x_lt_ind) + lx;
    else
        %Calculate Distance Components for ortogonal cell

        rz = XYZ_data(i,3) - XYZ_data(:,3);
        z_gt_ind=find(rz > lz/2); z_lt_ind=find(rz < - lz/2);
        rz(z_gt_ind) = rz(z_gt_ind) - lz;
        rz(z_lt_ind) = rz(z_lt_ind) + lz;

        ry = XYZ_data(i,2) - XYZ_data(:,2);
        y_gt_ind=find(ry > ly/2); y_lt_ind=find(ry < - ly/2);
        ry(y_gt_ind) = ry(y_gt_ind) - ly;
        ry(y_lt_ind) = ry(y_lt_ind) + ly;

        rx = XYZ_data(i,1) - XYZ_data(:,1);
        x_gt_ind=find(rx > lx/2); x_lt_ind=find(rx < - lx/2);
        rx(x_gt_ind) = rx(x_gt_ind) - lx;
        rx(x_lt_ind) = rx(x_lt_ind) + lx;

    end

    r = sqrt( rx(:,1).^2 + ry(:,1).^2 + rz(:,1).^2 ); % distance calc.
    bond_in=intersect(find(r > 0), find(r < max_neigh_distance));
    dist_matrix(:,i)=r;


    % Else if we already called dist_matrix_atom...
    %     r = dist_matrix(:,i);
    %     rx= X_dist(:,i);
    %     ry= Y_dist(:,i);
    %     rz= Z_dist(:,i);
    %     bond_in=intersect(find(r > 0), find(r < max_neigh_distance));
    %

    n=1;
    Neigh_ind=zeros(12,1);Neigh_vec=zeros(12,3);
    for j=1:length(bond_in)
        if [atom(i).molid]==[atom(bond_in(j)).molid] && (strncmpi([atom(i).type],[atom(bond_in(j)).type],1) == 0) % This checks for bonds between equal element types
            % Original, uncomment this section
            % max_distance = max_short_dist;
            % Only test
            if strncmpi(strtrim(XYZ_labels(i)),'H',1) || strncmpi(strtrim(XYZ_labels(bond_in(j))),'H',1)
                max_distance = rmaxshort;
            elseif strcmpi(strtrim(XYZ_labels(i)),'Oalhh') || strcmp(strtrim(XYZ_labels(i)),'Osih')
                if rmaxlong < 2.25
                    max_distance = 2.25;
                else
                    max_distance = rmaxlong;
                end
                %                 disp('Looking for M-O-H bonds')
            else
                max_distance = rmaxlong;
            end

            if r(bond_in(j)) < 0.6
                disp('Atoms too close!!!')
                r(bond_in(j))
                [i,bond_in(j)]
                XYZ_labels(i)
                XYZ_labels(bond_in(j))
                XYZ_data(i,:)
                XYZ_data(bond_in(j),:)
                overlap_index=[overlap_index; {i bond_in(j) r(bond_in(j)) XYZ_labels(i) XYZ_labels(bond_in(j)) XYZ_data(i,:) XYZ_data(bond_in(j),:)}];
            elseif r(bond_in(j)) > max_distance && r(bond_in(j)) < 1.25
                disp('Atoms pretty close...')
                r(bond_in(j))
                [i,bond_in(j)]
                XYZ_labels(i)
                XYZ_labels(bond_in(j))
                XYZ_data(i,:)
                XYZ_data(bond_in(j),:)
                close_count=close_count+1;
                overlap_index=[overlap_index; {i bond_in(j) r(bond_in(j)) XYZ_labels(i) XYZ_labels(bond_in(j)) XYZ_data(i,:) XYZ_data(bond_in(j),:)}];
            end

            if r(bond_in(j)) > max_distance/3 && r(bond_in(j)) < max_distance %strncmpi(XYZ_labels(i),strtrim(XYZ_labels(j)),1) == 0;
                if strncmpi(strtrim(XYZ_labels(i)),{'OW'},2)% || strncmpi(strtrim(XYZ_labels(bond_in(j))),{'OW'},2); % < bond_in(j) && ismember(XYZ_labels(i),{'Ow','Hw','OW','HW','HW1','HW2'}) > 0;
                    if bond_in(j) > i && bond_in(j) < i+3 %strncmpi(strtrim(XYZ_labels(i)),{'Ow'},2) && bond_in(j) > i && bond_in(j) < i+3;
                        Bond_index(b,1)= min([i bond_in(j)]);
                        Bond_index(b,2)= max([i bond_in(j)]);
                        Bond_index(b,3)= r(bond_in(j));
                        b=b+1;
                        if r(bond_in(j)) < rmaxshort % This should always be true right?
                            Neigh_ind(n,1)= bond_in(j);
                            Neigh_vec(n,1:3) = -[rx(bond_in(j)) ry(bond_in(j)) rz(bond_in(j))];
                            n=n+1;
                        end
                    end
                elseif strncmpi(strtrim(XYZ_labels(i)),{'HW'},2)
                    % disp('HW')
                elseif strncmpi(strtrim(XYZ_labels(i)),{'H'},1) && strncmpi(strtrim(XYZ_labels(bond_in(j))),{'H'},1)
                    %                     disp('disallowed a H-H bond')
                elseif ismember({'H'},[XYZ_labels(i) XYZ_labels(bond_in(j))]) > 0 || ismember({'Oalhh'},[XYZ_labels(i) XYZ_labels(bond_in(j))]) > 0 || ismember({'Osih'},[XYZ_labels(i) XYZ_labels(j)]) > 0 && ismember(XYZ_labels(bond_in(j)),{'Ow','Hw','OW','HW','HW1','HW2'}) == 0
                    Bond_index(b,1)= min([i bond_in(j)]);
                    Bond_index(b,2)= max([i bond_in(j)]);
                    Bond_index(b,3)= r(bond_in(j));
                    b=b+1;
                    if r(bond_in(j)) < max_distance % This should always be true right?
                        Neigh_ind(n,1)= bond_in(j);
                        Neigh_vec(n,1:3) = -[rx(bond_in(j)) ry(bond_in(j)) rz(bond_in(j))];
                        n=n+1;
                    end
                elseif ~strncmpi(strtrim(XYZ_labels(i)),{'OW'},2) || ~strncmpi(strtrim(XYZ_labels(i)),{'HW'},2)
                    if bond_in(j) < i
                        Bond_index(b,1)= min([i bond_in(j)]);
                        Bond_index(b,2)= max([i bond_in(j)]);
                        Bond_index(b,3)= r(bond_in(j));
                        b=b+1;
                    end
                    if r(bond_in(j)) < max_distance % This should always be true right?
                        Neigh_ind(n,1)= bond_in(j);
                        Neigh_vec(n,1:3) = -[rx(bond_in(j)) ry(bond_in(j)) rz(bond_in(j))];
                        n=n+1;
                    end
                end
            end

        end % test

        Neigh_ind(~any(Neigh_ind,2),:) = [];
        Neigh_vec(~any(Neigh_vec,2),:) = [];

        for v=1:size(Neigh_ind,1)
            for w=1:size(Neigh_ind,1) % From v or from 1?
                angle=rad2deg(atan2(norm(cross(Neigh_vec(v,:),Neigh_vec(w,:))),dot(Neigh_vec(v,:),Neigh_vec(w,:))));
                if angle > 0 && angle <= 180 % Do we need this??
                    if v < w
                        Angle_index(a,1)= Neigh_ind(v,1);
                        Angle_index(a,2)= i;
                        Angle_index(a,3)= Neigh_ind(w,1);
                        Angle_index(a,4)= angle;
                        Angle_index(a,5:7)= Neigh_vec(v,:);
                        Angle_index(a,8:10)= Neigh_vec(w,:);
                        a=a+1;
                    else
                        Angle_index(a,1)= Neigh_ind(w,1);
                        Angle_index(a,2)= i;
                        Angle_index(a,3)= Neigh_ind(v,1);
                        Angle_index(a,4)= angle;
                        Angle_index(a,5:7)= Neigh_vec(w,:);
                        Angle_index(a,8:10)= Neigh_vec(v,:);
                        a=a+1;
                    end
                end
            end
        end
    end
    if mod(i,1000)==1
        if i-1>0
            i-1
        end
    end
end
i

[Y,I]=sort(Bond_index(:,1));
Bond_index=Bond_index(I,:);
Bond_index = unique(Bond_index,'rows','stable');

[Y,I]=sort(Angle_index(:,1));
Angle_index=Angle_index(I,:);
Angle_index = unique(Angle_index,'rows','stable');

[Y,I]=sort(Angle_index(:,2));
Angle_index=Angle_index(I,:);
Angle_index = unique(Angle_index,'rows','stable');

overlap_index=overlap_index(1:size(overlap_index,1)/2,:);
% [Y,I]=sort(cell2mat(overlap_index(:,2)));
% overlap_index=overlap_index(I,:);
% overlap_index = unique(overlap_index,'rows','stable');

Bond_index(~any(Bond_index,2),:) = [];
Angle_index(~any(Angle_index,2),:) = [];
% overlap_index(~any(overlap_index,2),:) = [];

nBonds=size(Bond_index,1);
nAngles=size(Angle_index,1);

try
    % Set a cutoff vector
    rmax=repmat(max_neigh_distance,nAtoms,1);
    % Reduce the cutoff vector for H - X
    rmax(strncmpi(strtrim(XYZ_labels),'H',1))=rmaxshort; %1.25;
    for i=1:size(atom,2)
        Neigh_ind=intersect(find(dist_matrix(:,i)>0),find(dist_matrix(:,i)<rmax(i)));%radius_ion([atom.type])));
        Neigh_dist=dist_matrix(Neigh_ind,i);
        atom(i).neigh.type = [atom(Neigh_ind).type]';
        atom(i).neigh.index = Neigh_ind;
        atom(i).neigh.dist = Neigh_dist;
        atom(i).neigh.coords = [[atom(Neigh_ind).x]' [atom(Neigh_ind).y]' [atom(Neigh_ind).z]']; % PBC NOT TAKEN INTO ACCOUNT!!!
        atom(i).bond.type = [];
        atom(i).bond.index = [];
        atom(i).bond.dist = [];
        atom(i).angle.type = [];
        atom(i).angle.index = [];
        atom(i).angle.angle = [];
        atom(i).angle.vec1 = [];
        atom(i).angle.vec2 = [];

        if ismember(i,Bond_index(:,1:2))
            [A,B]=find(Bond_index(:,1:2)==i);
            atom(i).bond.type = 1;
            atom(i).bond.index = Bond_index(A,1:2);
            atom(i).bond.dist = Bond_index(A,3);
            if ismember(i,Angle_index(:,1:3))
                %                 [C,D]=find(Angle_index(:,1:3)==i);
                [C,D]=find(Angle_index(:,2)==i);
                atom(i).angle.type = 1;
                atom(i).angle.index = Angle_index(C,1:3);
                atom(i).angle.angle = Angle_index(C,4);
                atom(i).angle.vec1 = Angle_index(C,5:7);
                atom(i).angle.vec2 = Angle_index(C,8:10);
            end
        end
        if mod(i,1000)==1
            if i-1>0
                i-1
            end
        end
    end
catch
    disp('Could not assign either bonds, neighbours or angles...')
end
if nargin > 4 %% This will print a whole lot more info to the calling workspace
    %%%%%%%%%%

    Atom_labels=unique([atom.type]);
    for i=1:length(Atom_labels)
        label_ind=find(strcmpi([atom.type],Atom_labels(i)));
        Tot_dist=[];Tot_CN=[];Tot_type=[];Tot_index=[];Tot_angleindex=[];Tot_bondindex=[];Tot_neighindex=[];Tot_coords=[];Tot_bonds=[];Tot_angles=[];
        for j=label_ind
            if numel([atom(j).neigh])>0
                Tot_index=[Tot_index; repmat(j,numel([atom(j).neigh.index]),1)];
                Tot_dist=[Tot_dist; [atom(j).neigh.dist]];
                CN_temp=numel([atom(j).neigh.dist]);
                Tot_CN=[Tot_CN;CN_temp*ones(CN_temp,1)];
                Tot_type=[Tot_type; [atom(j).neigh.type]];
                Tot_neighindex=[Tot_neighindex; [atom(j).neigh.index]];
                Tot_coords=[Tot_coords; [atom(j).neigh.coords]];
            end

            if numel([atom(j).bond])>0
                Tot_bondindex=[Tot_bondindex; [atom(j).bond.index]];
                Tot_bonds=[Tot_bonds; [atom(j).bond.dist]];
            end
            if numel([atom(j).angle])>0
                Tot_angleindex=[Tot_angleindex; [atom(j).angle.index]];
                Tot_angles=[Tot_angles; [atom(j).angle.angle] CN_temp*ones(numel([atom(j).angle.angle]),1)]; %
            end
        end
        try
            assignin('caller',strcat(char(Atom_labels(i)),'_dist')',[num2cell(Tot_index,2) num2cell(Tot_neighindex,2) Tot_type num2cell(Tot_dist,2) num2cell(Tot_CN,2)]);
            assignin('caller',strcat(char(Atom_labels(i)),'_coords')',[[atom(Tot_neighindex).x]' [atom(Tot_neighindex).y]' [atom(Tot_neighindex).z]']);
            assignin('caller',strcat(char(Atom_labels(i)),'_bonds')',[Tot_bondindex Tot_bonds]);
            assignin('caller',strcat(char(Atom_labels(i)),'_angles')',[Tot_angleindex Tot_angles]);
            assignin('caller',strcat(char(Atom_labels(i)),'_atom')',atom(ismember([atom.type],Atom_labels(i))));

            assignin('base',strcat(char(Atom_labels(i)),'_dist')',[num2cell(Tot_index,2) num2cell(Tot_neighindex,2) Tot_type num2cell(Tot_dist,2) num2cell(Tot_CN,2)]);
            assignin('base',strcat(char(Atom_labels(i)),'_coords')',[[atom(Tot_neighindex).x]' [atom(Tot_neighindex).y]' [atom(Tot_neighindex).z]']);
            assignin('base',strcat(char(Atom_labels(i)),'_bonds')',[Tot_bondindex Tot_bonds]);
            assignin('base',strcat(char(Atom_labels(i)),'_angles')',[Tot_angleindex Tot_angles]);
            assignin('base',strcat(char(Atom_labels(i)),'_atom')',atom(ismember([atom.type],Atom_labels(i))));
        catch
            assignin('base',strcat(char(Atom_labels(i)),'_dist')',[num2cell(Tot_index,2) num2cell(Tot_neighindex,2) Tot_type num2cell(Tot_dist,2) num2cell(Tot_CN,2)]);
            assignin('base',strcat(char(Atom_labels(i)),'_coords')',[[atom(Tot_neighindex).x]' [atom(Tot_neighindex).y]' [atom(Tot_neighindex).z]']);
            assignin('base',strcat(char(Atom_labels(i)),'_bonds')',[Tot_bondindex Tot_bonds]);
            assignin('base',strcat(char(Atom_labels(i)),'_angles')',[Tot_angleindex Tot_angles]);
            assignin('base',strcat(char(Atom_labels(i)),'_atom')',atom(ismember([atom.type],Atom_labels(i))));
        end
    end

    try
        for i=1:size(Bond_index,1)
            Bondstruct(i).types=strcat(atom(Bond_index(i,1)).type,atom(Bond_index(i,2)).type);
            Bondstruct(i).dist=Bond_index(i,3);
        end
        Bondtypes=unique([Bondstruct.types]);

        for i=1:size(Bondtypes,2)
            ind=strcmp([Bondstruct.types],Bondtypes(i));
            Ave_Bonds(i).types=Bondtypes(i);
            Ave_Bonds(i).dist=mean([Bondstruct(ind).dist]);
            Ave_Bonds(i).dist_std=std([Bondstruct(ind).dist]);
        end

        for i=1:size(Angle_index,1)
            Anglestruct(i).types=strcat(atom(Angle_index(i,1)).type,atom(Angle_index(i,2)).type,atom(Angle_index(i,3)).type);
            Anglestruct(i).angle=Angle_index(i,4);
        end
        Angletypes=unique([Anglestruct.types]);

        for i=1:size(Angletypes,2)
            ind=strcmp([Anglestruct.types],Angletypes(i));
            Ave_Angles(i).types=Angletypes(i);
            Ave_Angles(i).angle=mean([Anglestruct(ind).angle]);
            Ave_Angles(i).angle_std=std([Anglestruct(ind).angle]);
        end

        assignin('caller','Ave_Bonds',Ave_Bonds);
        assignin('caller','Ave_Angles',Ave_Angles);

    catch
        disp('Could not calculate average bonds and/or angles')
    end

end

[Y,I]=sort(Bond_index(:,2));
Bond_index=Bond_index(I,:);
Bond_index = unique(Bond_index,'rows','stable');

[Y,I]=sort(Bond_index(:,1));
Bond_index=Bond_index(I,:);
Bond_index = unique(Bond_index,'rows','stable');

[Y,I]=sort(Angle_index(:,1));
Angle_index=Angle_index(I,:);
Angle_index = unique(Angle_index,'rows','stable');

[Y,I]=sort(Angle_index(:,2));
Angle_index=Angle_index(I,:);
Angle_index = unique(Angle_index,'rows','stable');

atom=order_attributes(atom);

try
    assignin('caller','dist_matrix',dist_matrix);
    assignin('caller','overlap_index',overlap_index);
    assignin('caller','Bond_index',Bond_index);
    assignin('caller','Angle_index',Angle_index);
    assignin('caller','nBonds',nBonds);
    assignin('caller','nAngles',nAngles);
catch
    assignin('base','dist_matrix',dist_matrix);
    assignin('base','overlap_index',overlap_index);
    assignin('base','Bond_index',Bond_index);
    assignin('base','Angle_index',Angle_index);
    assignin('base','nBonds',nBonds);
    assignin('base','nAngles',nAngles);
end

% toc

##### SOURCE END #####
-->
</body>
</html>
