
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>bond_angle_atom.m</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-04-21"><meta name="DC.source" content="bond_angle_atom.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>bond_angle_atom.m</h1><!--introduction--><div><ul><li>This function tries to find all bonds and angles of the atom struct</li><li>One optional argument like 'more' will give more bond info</li><li>atom is the atom struct</li><li>Box_dim is the box dimension vector</li></ul></div><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Version</a></li><li><a href="#2">Contact</a></li><li><a href="#3">Examples</a></li></ul></div><h2 id="1">Version</h2><p>2.03</p><h2 id="2">Contact</h2><p>Please report bugs to <a href="mailto:michael.holmboe@umu.se">michael.holmboe@umu.se</a></p><h2 id="3">Examples</h2><div><ol><li>atom=bond_angle_atom(atom,Box_dim,1.25,2.25)</li><li>atom=bond_angle_atom(atom,Box_dim,1.25,2.25,'more')</li></ol></div><pre class="codeinput"><span class="keyword">function</span> atom=bond_angle_atom(atom,Box_dim,rmaxshort,rmaxlong,varargin)
</pre><p>tic</p><pre class="codeinput">nAtoms=size(atom,2);
<span class="comment">% max_short_dist=1.2;</span>
<span class="comment">% max_long_dist=2.3;</span>

XYZ_labels=[atom.type]';
XYZ_data=[[atom.x]' [atom.y]' [atom.z]'];

lx=Box_dim(1);ly=Box_dim(2);lz=Box_dim(3);
<span class="keyword">if</span> length(Box_dim) &gt; 3
    xy=Box_dim(6);xz=Box_dim(8);yz=Box_dim(9);
<span class="keyword">else</span>
    xy=0;xz=0;yz=0;
<span class="keyword">end</span>

close_count=1;
Bond_index=zeros(4*size(XYZ_data,1),3);
Angle_index=zeros(4*size(XYZ_data,1),4);
dist_matrix=zeros(nAtoms,nAtoms);
<span class="comment">% dist_matrix = dist_matrix_atom(atom,Box_dim); % Do this if you want to calc dist_matrix_atom first</span>
b=1;a=1; overlap_index=[];
<span class="keyword">for</span> i = 1:size(XYZ_data,1)

    <span class="comment">%     disp('Setting max_neigh_distance to... ')</span>
    <span class="comment">%     max_neigh_distance = max_long_dist %2.25; % Set large max_neigh_distance so that we can find Si-O-H and Al-OH2 bonds %max_long_dist;%2.3</span>
    <span class="comment">%     disp('If you have problems, change back to 2.25 on line 43 in bond_angle_atom()')</span>
    <span class="comment">%     max_neigh_distance = max_long_dist; % Change to 2.25 if adding edge bonds</span>

    <span class="keyword">if</span> strcmpi(strtrim(XYZ_labels(i)),<span class="string">'Oalhh'</span>) || strcmp(strtrim(XYZ_labels(i)),<span class="string">'Osih'</span>)
        <span class="keyword">if</span> rmaxlong &lt; 2.25
            max_neigh_distance = 2.25;
        <span class="keyword">else</span>
            max_neigh_distance = rmaxlong;
        <span class="keyword">end</span>
    <span class="keyword">else</span>
        max_neigh_distance = rmaxlong;
    <span class="keyword">end</span>
    <span class="comment">%                 disp('Looking for M-O-H bonds')</span>

    <span class="keyword">if</span> length(Box_dim)&gt;3
        <span class="comment">%Calculate Distance Components for triclic cell</span>
        rz = XYZ_data(i,3) - XYZ_data(:,3);
        ry = XYZ_data(i,2) - XYZ_data(:,2);
        rx = XYZ_data(i,1) - XYZ_data(:,1);

        z_gt_ind=find(rz &gt; lz/2); z_lt_ind=find(rz &lt; - lz/2);
        rz(z_gt_ind) = rz(z_gt_ind) - lz;
        rz(z_lt_ind) = rz(z_lt_ind) + lz;
        rx(z_gt_ind) = rx(z_gt_ind) - xz;
        rx(z_lt_ind) = rx(z_lt_ind) + xz;
        ry(z_gt_ind) = ry(z_gt_ind) - yz;
        ry(z_lt_ind) = ry(z_lt_ind) + yz;

        y_gt_ind=find(ry &gt; ly/2); y_lt_ind=find(ry &lt; - ly/2);
        ry(y_gt_ind) = ry(y_gt_ind) - ly;
        ry(y_lt_ind) = ry(y_lt_ind) + ly;
        rx(y_gt_ind) = rx(y_gt_ind) - xy;
        rx(y_lt_ind) = rx(y_lt_ind) + xy;

        x_gt_ind=find(rx &gt; lx/2); x_lt_ind=find(rx &lt; - lx/2);
        rx(x_gt_ind) = rx(x_gt_ind) - lx;
        rx(x_lt_ind) = rx(x_lt_ind) + lx;
    <span class="keyword">else</span>
        <span class="comment">%Calculate Distance Components for ortogonal cell</span>

        rz = XYZ_data(i,3) - XYZ_data(:,3);
        z_gt_ind=find(rz &gt; lz/2); z_lt_ind=find(rz &lt; - lz/2);
        rz(z_gt_ind) = rz(z_gt_ind) - lz;
        rz(z_lt_ind) = rz(z_lt_ind) + lz;

        ry = XYZ_data(i,2) - XYZ_data(:,2);
        y_gt_ind=find(ry &gt; ly/2); y_lt_ind=find(ry &lt; - ly/2);
        ry(y_gt_ind) = ry(y_gt_ind) - ly;
        ry(y_lt_ind) = ry(y_lt_ind) + ly;

        rx = XYZ_data(i,1) - XYZ_data(:,1);
        x_gt_ind=find(rx &gt; lx/2); x_lt_ind=find(rx &lt; - lx/2);
        rx(x_gt_ind) = rx(x_gt_ind) - lx;
        rx(x_lt_ind) = rx(x_lt_ind) + lx;

    <span class="keyword">end</span>

    r = sqrt( rx(:,1).^2 + ry(:,1).^2 + rz(:,1).^2 ); <span class="comment">% distance calc.</span>
    bond_in=intersect(find(r &gt; 0), find(r &lt; max_neigh_distance));
    dist_matrix(:,i)=r;


    <span class="comment">% Else if we already called dist_matrix_atom...</span>
    <span class="comment">%     r = dist_matrix(:,i);</span>
    <span class="comment">%     rx= X_dist(:,i);</span>
    <span class="comment">%     ry= Y_dist(:,i);</span>
    <span class="comment">%     rz= Z_dist(:,i);</span>
    <span class="comment">%     bond_in=intersect(find(r &gt; 0), find(r &lt; max_neigh_distance));</span>
    <span class="comment">%</span>


    n=1;
    Neigh_ind=zeros(12,1);Neigh_vec=zeros(12,3);
    <span class="keyword">for</span> j=1:length(bond_in)
        <span class="keyword">if</span> [atom(i).molid]==[atom(bond_in(j)).molid]
            <span class="comment">% Original, uncomment this section</span>
            <span class="comment">% max_distance = max_short_dist;</span>
            <span class="comment">% Only test</span>
            <span class="keyword">if</span> strncmpi(strtrim(XYZ_labels(i)),<span class="string">'H'</span>,1) || strncmpi(strtrim(XYZ_labels(bond_in(j))),<span class="string">'H'</span>,1)
                max_distance = rmaxshort;
            <span class="keyword">elseif</span> strcmpi(strtrim(XYZ_labels(i)),<span class="string">'Oalhh'</span>) || strcmp(strtrim(XYZ_labels(i)),<span class="string">'Osih'</span>)
                <span class="keyword">if</span> rmaxlong &lt; 2.25
                    max_distance = 2.25;
                <span class="keyword">else</span>
                    max_distance = rmaxlong;
                <span class="keyword">end</span>
                <span class="comment">%                 disp('Looking for M-O-H bonds')</span>
            <span class="keyword">else</span>
                max_distance = rmaxlong;
            <span class="keyword">end</span>

            <span class="keyword">if</span> r(bond_in(j)) &lt; 0.6
                disp(<span class="string">'Atoms too close!!!'</span>)
                r(bond_in(j))
                [i,bond_in(j)]
                XYZ_labels(i)
                XYZ_labels(bond_in(j))
                XYZ_data(i,:)
                XYZ_data(bond_in(j),:)
                overlap_index=[overlap_index; {i bond_in(j) r(bond_in(j)) XYZ_labels(i) XYZ_labels(bond_in(j)) XYZ_data(i,:) XYZ_data(bond_in(j),:)}];
            <span class="keyword">elseif</span> r(bond_in(j)) &gt; max_distance &amp;&amp; r(bond_in(j)) &lt; 1.25
                disp(<span class="string">'Atoms pretty close...'</span>)
                r(bond_in(j))
                [i,bond_in(j)]
                XYZ_labels(i)
                XYZ_labels(bond_in(j))
                XYZ_data(i,:)
                XYZ_data(bond_in(j),:)
                close_count=close_count+1;
                overlap_index=[overlap_index; {i bond_in(j) r(bond_in(j)) XYZ_labels(i) XYZ_labels(bond_in(j)) XYZ_data(i,:) XYZ_data(bond_in(j),:)}];
            <span class="keyword">end</span>
            <span class="keyword">if</span> r(bond_in(j)) &gt; max_distance/3 &amp;&amp; r(bond_in(j)) &lt; max_distance <span class="comment">%strncmpi(XYZ_labels(i),strtrim(XYZ_labels(j)),1) == 0;</span>
                <span class="keyword">if</span> strncmpi(strtrim(XYZ_labels(i)),{<span class="string">'OW'</span>},2)<span class="comment">% || strncmpi(strtrim(XYZ_labels(bond_in(j))),{'OW'},2); % &lt; bond_in(j) &amp;&amp; ismember(XYZ_labels(i),{'Ow','Hw','OW','HW','HW1','HW2'}) &gt; 0;</span>
                    <span class="keyword">if</span> bond_in(j) &gt; i &amp;&amp; bond_in(j) &lt; i+3 <span class="comment">%strncmpi(strtrim(XYZ_labels(i)),{'Ow'},2) &amp;&amp; bond_in(j) &gt; i &amp;&amp; bond_in(j) &lt; i+3;</span>
                        Bond_index(b,1)= min([i bond_in(j)]);
                        Bond_index(b,2)= max([i bond_in(j)]);
                        Bond_index(b,3)= r(bond_in(j));
                        b=b+1;
                        <span class="keyword">if</span> r(bond_in(j)) &lt; rmaxshort <span class="comment">% This should always be true right?</span>
                            Neigh_ind(n,1)= bond_in(j);
                            Neigh_vec(n,1:3) = [rx(bond_in(j)) ry(bond_in(j)) rz(bond_in(j))];
                            n=n+1;
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">elseif</span> strncmpi(strtrim(XYZ_labels(i)),{<span class="string">'HW'</span>},2)
                    <span class="comment">% disp('HW')</span>
                <span class="keyword">elseif</span> strncmpi(strtrim(XYZ_labels(i)),{<span class="string">'H'</span>},1) &amp;&amp; strncmpi(strtrim(XYZ_labels(bond_in(j))),{<span class="string">'H'</span>},1)
                    <span class="comment">%                     disp('disallowed a H-H bond')</span>
                <span class="keyword">elseif</span> ismember({<span class="string">'H'</span>},[XYZ_labels(i) XYZ_labels(bond_in(j))]) &gt; 0 || ismember({<span class="string">'Oalhh'</span>},[XYZ_labels(i) XYZ_labels(bond_in(j))]) &gt; 0 || ismember({<span class="string">'Osih'</span>},[XYZ_labels(i) XYZ_labels(j)]) &gt; 0 &amp;&amp; ismember(XYZ_labels(bond_in(j)),{<span class="string">'Ow'</span>,<span class="string">'Hw'</span>,<span class="string">'OW'</span>,<span class="string">'HW'</span>,<span class="string">'HW1'</span>,<span class="string">'HW2'</span>}) == 0
                    Bond_index(b,1)= min([i bond_in(j)]);
                    Bond_index(b,2)= max([i bond_in(j)]);
                    Bond_index(b,3)= r(bond_in(j));
                    b=b+1;
                    <span class="keyword">if</span> r(bond_in(j)) &lt; max_distance <span class="comment">% This should always be true right?</span>
                        Neigh_ind(n,1)= bond_in(j);
                        Neigh_vec(n,1:3) = [rx(bond_in(j)) ry(bond_in(j)) rz(bond_in(j))];
                        n=n+1;
                    <span class="keyword">end</span>
                <span class="keyword">elseif</span> ~strncmpi(strtrim(XYZ_labels(i)),{<span class="string">'OW'</span>},2) || ~strncmpi(strtrim(XYZ_labels(i)),{<span class="string">'HW'</span>},2)
                    <span class="keyword">if</span> bond_in(j) &lt; i
                        Bond_index(b,1)= min([i bond_in(j)]);
                        Bond_index(b,2)= max([i bond_in(j)]);
                        Bond_index(b,3)= r(bond_in(j));
                        b=b+1;
                    <span class="keyword">end</span>
                    <span class="keyword">if</span> r(bond_in(j)) &lt; max_distance <span class="comment">% This should always be true right?</span>
                        Neigh_ind(n,1)= bond_in(j);
                        Neigh_vec(n,1:3) = [rx(bond_in(j)) ry(bond_in(j)) rz(bond_in(j))];
                        n=n+1;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>

        <span class="keyword">end</span> <span class="comment">% test</span>

        Neigh_ind(~any(Neigh_ind,2),:) = [];
        Neigh_vec(~any(Neigh_vec,2),:) = [];

        <span class="keyword">for</span> v=1:size(Neigh_ind,1)
            <span class="keyword">for</span> w=1:size(Neigh_ind,1) <span class="comment">% From v or from 1?</span>
                angle=rad2deg(atan2(norm(cross(Neigh_vec(v,:),Neigh_vec(w,:))),dot(Neigh_vec(v,:),Neigh_vec(w,:))));
                <span class="keyword">if</span> angle &gt; 0 &amp;&amp; angle &lt;= 150 <span class="comment">% Do we need this??</span>
                    <span class="keyword">if</span> v &lt; w
                        Angle_index(a,1)= Neigh_ind(v,1);
                        Angle_index(a,2)= i;
                        Angle_index(a,3)= Neigh_ind(w,1);
                        Angle_index(a,4)= angle;
                        Angle_index(a,5:7)= Neigh_vec(v,:);
                        Angle_index(a,8:10)= Neigh_vec(w,:);
                        a=a+1;
                    <span class="keyword">else</span>
                        Angle_index(a,1)= Neigh_ind(w,1);
                        Angle_index(a,2)= i;
                        Angle_index(a,3)= Neigh_ind(v,1);
                        Angle_index(a,4)= angle;
                        Angle_index(a,5:7)= Neigh_vec(w,:);
                        Angle_index(a,8:10)= Neigh_vec(v,:);
                        a=a+1;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> mod(i,100)==1
        i-1
    <span class="keyword">end</span>
<span class="keyword">end</span>


[Y,I]=sort(Bond_index(:,1));
Bond_index=Bond_index(I,:);
Bond_index = unique(Bond_index,<span class="string">'rows'</span>,<span class="string">'stable'</span>);

[Y,I]=sort(Angle_index(:,2));
Angle_index=Angle_index(I,:);
Angle_index = unique(Angle_index,<span class="string">'rows'</span>,<span class="string">'stable'</span>);

overlap_index=overlap_index(1:size(overlap_index,1)/2,:);
<span class="comment">% [Y,I]=sort(cell2mat(overlap_index(:,2)));</span>
<span class="comment">% overlap_index=overlap_index(I,:);</span>
<span class="comment">% overlap_index = unique(overlap_index,'rows','stable');</span>

Bond_index(~any(Bond_index,2),:) = [];
Angle_index(~any(Angle_index,2),:) = [];
<span class="comment">% overlap_index(~any(overlap_index,2),:) = [];</span>


nBonds=size(Bond_index,1);
nAngles=size(Angle_index,1);

<span class="keyword">if</span> nargin &gt; 4 <span class="comment">%% This will print a whole lot more info to the calling workspace</span>
    <span class="comment">% Set a cutoff vector</span>
    rmax=repmat(max_neigh_distance,nAtoms,1);
    <span class="comment">% Reduce the cutoff vector for H - X</span>
    rmax(strncmpi(strtrim(XYZ_labels),<span class="string">'H'</span>,1))=1.25;
    <span class="keyword">for</span> i=1:size(atom,2)
        Neigh_ind=intersect(find(dist_matrix(:,i)&gt;0),find(dist_matrix(:,i)&lt;rmax(i)));<span class="comment">%radius_ion([atom.type])));</span>
        Neigh_dist=dist_matrix(Neigh_ind,i);
        atom(i).neigh.type = [atom(Neigh_ind).type]';
        atom(i).neigh.index = Neigh_ind;
        atom(i).neigh.dist = Neigh_dist;
        atom(i).neigh.coords = [[atom(Neigh_ind).x]' [atom(Neigh_ind).y]' [atom(Neigh_ind).z]']; <span class="comment">% PBC NOT TAKEN INTO ACCOUNT!!!</span>
        atom(i).bond.type = [];
        atom(i).bond.index = [];
        atom(i).bond.dist = [];
        atom(i).angle.type = [];
        atom(i).angle.index = [];
        atom(i).angle.angle = [];
        atom(i).angle.vec1 = [];
        atom(i).angle.vec2 = [];

        <span class="keyword">if</span> ismember(i,Bond_index(:,1:2))
            [A,B]=find(Bond_index(:,1:2)==i);
            atom(i).bond.type = 1;
            atom(i).bond.index = Bond_index(A,1:2);
            atom(i).bond.dist = Bond_index(A,3);
            <span class="keyword">if</span> ismember(i,Angle_index(:,1:3))
                <span class="comment">%                 [C,D]=find(Angle_index(:,1:3)==i);</span>
                [C,D]=find(Angle_index(:,2)==i);
                atom(i).angle.type = 1;
                atom(i).angle.index = Angle_index(C,1:3);
                atom(i).angle.angle = Angle_index(C,4);
                atom(i).angle.vec1 = Angle_index(C,5:7);
                atom(i).angle.vec2 = Angle_index(C,8:10);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">if</span> mod(i,100)==1
            i-1
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">%%%%%%%%%%</span>

    Atom_labels=unique([atom.type]);
    <span class="keyword">for</span> i=1:length(Atom_labels)
        label_ind=find(strcmpi([atom.type],Atom_labels(i)));
        Tot_dist=[];Tot_type=[];Tot_index=[];Tot_angleindex=[];Tot_bondindex=[];Tot_neighindex=[];Tot_coords=[];Tot_bonds=[];Tot_angles=[];
        <span class="keyword">for</span> j=label_ind
            <span class="keyword">if</span> numel([atom(j).neigh])&gt;0
                Tot_index=[Tot_index; repmat(j,numel([atom(j).neigh.index]),1)];
                Tot_dist=[Tot_dist; [atom(j).neigh.dist]];
                Tot_type=[Tot_type; [atom(j).neigh.type]];
                Tot_neighindex=[Tot_neighindex; [atom(j).neigh.index]];
                Tot_coords=[Tot_coords; [atom(j).neigh.coords]];
            <span class="keyword">end</span>

            <span class="keyword">if</span> numel([atom(j).bond])&gt;0
                Tot_bondindex=[Tot_bondindex; [atom(j).bond.index]];
                Tot_bonds=[Tot_bonds; [atom(j).bond.dist]];
            <span class="keyword">end</span>
            <span class="keyword">if</span> numel([atom(j).angle])&gt;0
                Tot_angleindex=[Tot_angleindex; [atom(j).angle.index]];
                Tot_angles=[Tot_angles; [atom(j).angle.angle]];
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">try</span>
            assignin(<span class="string">'caller'</span>,strcat(char(Atom_labels(i)),<span class="string">'_dist'</span>)',[num2cell(Tot_index) num2cell(Tot_neighindex) Tot_type num2cell(Tot_dist)]);
            assignin(<span class="string">'caller'</span>,strcat(char(Atom_labels(i)),<span class="string">'_coords'</span>)',[[atom(Tot_neighindex).x]' [atom(Tot_neighindex).y]' [atom(Tot_neighindex).z]']);
            assignin(<span class="string">'caller'</span>,strcat(char(Atom_labels(i)),<span class="string">'_bonds'</span>)',[Tot_bondindex Tot_bonds]);
            assignin(<span class="string">'caller'</span>,strcat(char(Atom_labels(i)),<span class="string">'_angles'</span>)',[Tot_angleindex Tot_angles]);
            assignin(<span class="string">'caller'</span>,strcat(char(Atom_labels(i)),<span class="string">'_atom'</span>)',atom(ismember([atom.type],Atom_labels(i))));
        <span class="keyword">catch</span>
            assignin(<span class="string">'base'</span>,strcat(char(Atom_labels(i)),<span class="string">'_dist'</span>)',[num2cell(Tot_index) num2cell(Tot_neighindex) Tot_type num2cell(Tot_dist)]);
            assignin(<span class="string">'base'</span>,strcat(char(Atom_labels(i)),<span class="string">'_coords'</span>)',[[atom(Tot_neighindex).x]' [atom(Tot_neighindex).y]' [atom(Tot_neighindex).z]']);
            assignin(<span class="string">'base'</span>,strcat(char(Atom_labels(i)),<span class="string">'_bonds'</span>)',[Tot_bondindex Tot_bonds]);
            assignin(<span class="string">'base'</span>,strcat(char(Atom_labels(i)),<span class="string">'_angles'</span>)',[Tot_angleindex Tot_angles]);
            assignin(<span class="string">'base'</span>,strcat(char(Atom_labels(i)),<span class="string">'_atom'</span>)',atom(ismember([atom.type],Atom_labels(i))));
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">try</span>
    assignin(<span class="string">'caller'</span>,<span class="string">'dist_matrix'</span>,dist_matrix);
    assignin(<span class="string">'caller'</span>,<span class="string">'overlap_index'</span>,overlap_index);
    assignin(<span class="string">'caller'</span>,<span class="string">'Bond_index'</span>,Bond_index);
    assignin(<span class="string">'caller'</span>,<span class="string">'Angle_index'</span>,Angle_index);
    assignin(<span class="string">'caller'</span>,<span class="string">'nBonds'</span>,nBonds);
    assignin(<span class="string">'caller'</span>,<span class="string">'nAngles'</span>,nAngles);
<span class="keyword">catch</span>
    assignin(<span class="string">'base'</span>,<span class="string">'dist_matrix'</span>,dist_matrix);
    assignin(<span class="string">'base'</span>,<span class="string">'overlap_index'</span>,overlap_index);
    assignin(<span class="string">'base'</span>,<span class="string">'Bond_index'</span>,Bond_index);
    assignin(<span class="string">'base'</span>,<span class="string">'Angle_index'</span>,Angle_index);
    assignin(<span class="string">'base'</span>,<span class="string">'nBonds'</span>,nBonds);
    assignin(<span class="string">'base'</span>,<span class="string">'nAngles'</span>,nAngles);
<span class="keyword">end</span>

<span class="comment">% toc</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% bond_angle_atom.m
% * This function tries to find all bonds and angles of the atom struct
% * One optional argument like 'more' will give more bond info
% * atom is the atom struct
% * Box_dim is the box dimension vector
%
%% Version
% 2.03
%
%% Contact
% Please report bugs to michael.holmboe@umu.se
%
%% Examples
% # atom=bond_angle_atom(atom,Box_dim,1.25,2.25)
% # atom=bond_angle_atom(atom,Box_dim,1.25,2.25,'more')
%

function atom=bond_angle_atom(atom,Box_dim,rmaxshort,rmaxlong,varargin)
%%
% tic

nAtoms=size(atom,2);
% max_short_dist=1.2;
% max_long_dist=2.3;

XYZ_labels=[atom.type]';
XYZ_data=[[atom.x]' [atom.y]' [atom.z]'];

lx=Box_dim(1);ly=Box_dim(2);lz=Box_dim(3);
if length(Box_dim) > 3
    xy=Box_dim(6);xz=Box_dim(8);yz=Box_dim(9);
else
    xy=0;xz=0;yz=0;
end

close_count=1;
Bond_index=zeros(4*size(XYZ_data,1),3);
Angle_index=zeros(4*size(XYZ_data,1),4);
dist_matrix=zeros(nAtoms,nAtoms);
% dist_matrix = dist_matrix_atom(atom,Box_dim); % Do this if you want to calc dist_matrix_atom first
b=1;a=1; overlap_index=[];
for i = 1:size(XYZ_data,1)
    
    %     disp('Setting max_neigh_distance to... ')
    %     max_neigh_distance = max_long_dist %2.25; % Set large max_neigh_distance so that we can find Si-O-H and Al-OH2 bonds %max_long_dist;%2.3
    %     disp('If you have problems, change back to 2.25 on line 43 in bond_angle_atom()')
    %     max_neigh_distance = max_long_dist; % Change to 2.25 if adding edge bonds
    
    if strcmpi(strtrim(XYZ_labels(i)),'Oalhh') || strcmp(strtrim(XYZ_labels(i)),'Osih')
        if rmaxlong < 2.25
            max_neigh_distance = 2.25;
        else
            max_neigh_distance = rmaxlong;
        end
    else
        max_neigh_distance = rmaxlong;
    end
    %                 disp('Looking for M-O-H bonds')
    
    if length(Box_dim)>3
        %Calculate Distance Components for triclic cell
        rz = XYZ_data(i,3) - XYZ_data(:,3);
        ry = XYZ_data(i,2) - XYZ_data(:,2);
        rx = XYZ_data(i,1) - XYZ_data(:,1);
        
        z_gt_ind=find(rz > lz/2); z_lt_ind=find(rz < - lz/2);
        rz(z_gt_ind) = rz(z_gt_ind) - lz;
        rz(z_lt_ind) = rz(z_lt_ind) + lz;
        rx(z_gt_ind) = rx(z_gt_ind) - xz;
        rx(z_lt_ind) = rx(z_lt_ind) + xz;
        ry(z_gt_ind) = ry(z_gt_ind) - yz;
        ry(z_lt_ind) = ry(z_lt_ind) + yz;
        
        y_gt_ind=find(ry > ly/2); y_lt_ind=find(ry < - ly/2);
        ry(y_gt_ind) = ry(y_gt_ind) - ly;
        ry(y_lt_ind) = ry(y_lt_ind) + ly;
        rx(y_gt_ind) = rx(y_gt_ind) - xy;
        rx(y_lt_ind) = rx(y_lt_ind) + xy;
        
        x_gt_ind=find(rx > lx/2); x_lt_ind=find(rx < - lx/2);
        rx(x_gt_ind) = rx(x_gt_ind) - lx;
        rx(x_lt_ind) = rx(x_lt_ind) + lx;
    else
        %Calculate Distance Components for ortogonal cell
        
        rz = XYZ_data(i,3) - XYZ_data(:,3);
        z_gt_ind=find(rz > lz/2); z_lt_ind=find(rz < - lz/2);
        rz(z_gt_ind) = rz(z_gt_ind) - lz;
        rz(z_lt_ind) = rz(z_lt_ind) + lz;
        
        ry = XYZ_data(i,2) - XYZ_data(:,2);
        y_gt_ind=find(ry > ly/2); y_lt_ind=find(ry < - ly/2);
        ry(y_gt_ind) = ry(y_gt_ind) - ly;
        ry(y_lt_ind) = ry(y_lt_ind) + ly;
        
        rx = XYZ_data(i,1) - XYZ_data(:,1);
        x_gt_ind=find(rx > lx/2); x_lt_ind=find(rx < - lx/2);
        rx(x_gt_ind) = rx(x_gt_ind) - lx;
        rx(x_lt_ind) = rx(x_lt_ind) + lx;
        
    end
    
    r = sqrt( rx(:,1).^2 + ry(:,1).^2 + rz(:,1).^2 ); % distance calc.
    bond_in=intersect(find(r > 0), find(r < max_neigh_distance));
    dist_matrix(:,i)=r;
    
    
    % Else if we already called dist_matrix_atom...
    %     r = dist_matrix(:,i);
    %     rx= X_dist(:,i);
    %     ry= Y_dist(:,i);
    %     rz= Z_dist(:,i);
    %     bond_in=intersect(find(r > 0), find(r < max_neigh_distance));
    %
    
    
    n=1;
    Neigh_ind=zeros(12,1);Neigh_vec=zeros(12,3);
    for j=1:length(bond_in)
        if [atom(i).molid]==[atom(bond_in(j)).molid]
            % Original, uncomment this section
            % max_distance = max_short_dist;
            % Only test
            if strncmpi(strtrim(XYZ_labels(i)),'H',1) || strncmpi(strtrim(XYZ_labels(bond_in(j))),'H',1)
                max_distance = rmaxshort;
            elseif strcmpi(strtrim(XYZ_labels(i)),'Oalhh') || strcmp(strtrim(XYZ_labels(i)),'Osih')
                if rmaxlong < 2.25
                    max_distance = 2.25;
                else
                    max_distance = rmaxlong;
                end
                %                 disp('Looking for M-O-H bonds')
            else
                max_distance = rmaxlong;
            end
            
            if r(bond_in(j)) < 0.6
                disp('Atoms too close!!!')
                r(bond_in(j))
                [i,bond_in(j)]
                XYZ_labels(i)
                XYZ_labels(bond_in(j))
                XYZ_data(i,:)
                XYZ_data(bond_in(j),:)
                overlap_index=[overlap_index; {i bond_in(j) r(bond_in(j)) XYZ_labels(i) XYZ_labels(bond_in(j)) XYZ_data(i,:) XYZ_data(bond_in(j),:)}];
            elseif r(bond_in(j)) > max_distance && r(bond_in(j)) < 1.25
                disp('Atoms pretty close...')
                r(bond_in(j))
                [i,bond_in(j)]
                XYZ_labels(i)
                XYZ_labels(bond_in(j))
                XYZ_data(i,:)
                XYZ_data(bond_in(j),:)
                close_count=close_count+1;
                overlap_index=[overlap_index; {i bond_in(j) r(bond_in(j)) XYZ_labels(i) XYZ_labels(bond_in(j)) XYZ_data(i,:) XYZ_data(bond_in(j),:)}];
            end
            if r(bond_in(j)) > max_distance/3 && r(bond_in(j)) < max_distance %strncmpi(XYZ_labels(i),strtrim(XYZ_labels(j)),1) == 0;
                if strncmpi(strtrim(XYZ_labels(i)),{'OW'},2)% || strncmpi(strtrim(XYZ_labels(bond_in(j))),{'OW'},2); % < bond_in(j) && ismember(XYZ_labels(i),{'Ow','Hw','OW','HW','HW1','HW2'}) > 0;
                    if bond_in(j) > i && bond_in(j) < i+3 %strncmpi(strtrim(XYZ_labels(i)),{'Ow'},2) && bond_in(j) > i && bond_in(j) < i+3;
                        Bond_index(b,1)= min([i bond_in(j)]);
                        Bond_index(b,2)= max([i bond_in(j)]);
                        Bond_index(b,3)= r(bond_in(j));
                        b=b+1;
                        if r(bond_in(j)) < rmaxshort % This should always be true right?
                            Neigh_ind(n,1)= bond_in(j);
                            Neigh_vec(n,1:3) = [rx(bond_in(j)) ry(bond_in(j)) rz(bond_in(j))];
                            n=n+1;
                        end
                    end
                elseif strncmpi(strtrim(XYZ_labels(i)),{'HW'},2)
                    % disp('HW')
                elseif strncmpi(strtrim(XYZ_labels(i)),{'H'},1) && strncmpi(strtrim(XYZ_labels(bond_in(j))),{'H'},1)
                    %                     disp('disallowed a H-H bond')
                elseif ismember({'H'},[XYZ_labels(i) XYZ_labels(bond_in(j))]) > 0 || ismember({'Oalhh'},[XYZ_labels(i) XYZ_labels(bond_in(j))]) > 0 || ismember({'Osih'},[XYZ_labels(i) XYZ_labels(j)]) > 0 && ismember(XYZ_labels(bond_in(j)),{'Ow','Hw','OW','HW','HW1','HW2'}) == 0
                    Bond_index(b,1)= min([i bond_in(j)]);
                    Bond_index(b,2)= max([i bond_in(j)]);
                    Bond_index(b,3)= r(bond_in(j));
                    b=b+1;
                    if r(bond_in(j)) < max_distance % This should always be true right?
                        Neigh_ind(n,1)= bond_in(j);
                        Neigh_vec(n,1:3) = [rx(bond_in(j)) ry(bond_in(j)) rz(bond_in(j))];
                        n=n+1;
                    end
                elseif ~strncmpi(strtrim(XYZ_labels(i)),{'OW'},2) || ~strncmpi(strtrim(XYZ_labels(i)),{'HW'},2)
                    if bond_in(j) < i
                        Bond_index(b,1)= min([i bond_in(j)]);
                        Bond_index(b,2)= max([i bond_in(j)]);
                        Bond_index(b,3)= r(bond_in(j));
                        b=b+1;
                    end
                    if r(bond_in(j)) < max_distance % This should always be true right?
                        Neigh_ind(n,1)= bond_in(j);
                        Neigh_vec(n,1:3) = [rx(bond_in(j)) ry(bond_in(j)) rz(bond_in(j))];
                        n=n+1;
                    end
                end
            end
            
        end % test
        
        Neigh_ind(~any(Neigh_ind,2),:) = [];
        Neigh_vec(~any(Neigh_vec,2),:) = [];
        
        for v=1:size(Neigh_ind,1)
            for w=1:size(Neigh_ind,1) % From v or from 1?
                angle=rad2deg(atan2(norm(cross(Neigh_vec(v,:),Neigh_vec(w,:))),dot(Neigh_vec(v,:),Neigh_vec(w,:))));
                if angle > 0 && angle <= 150 % Do we need this??
                    if v < w
                        Angle_index(a,1)= Neigh_ind(v,1);
                        Angle_index(a,2)= i;
                        Angle_index(a,3)= Neigh_ind(w,1);
                        Angle_index(a,4)= angle;
                        Angle_index(a,5:7)= Neigh_vec(v,:);
                        Angle_index(a,8:10)= Neigh_vec(w,:);
                        a=a+1;
                    else
                        Angle_index(a,1)= Neigh_ind(w,1);
                        Angle_index(a,2)= i;
                        Angle_index(a,3)= Neigh_ind(v,1);
                        Angle_index(a,4)= angle;
                        Angle_index(a,5:7)= Neigh_vec(w,:);
                        Angle_index(a,8:10)= Neigh_vec(v,:);
                        a=a+1;
                    end
                end
            end
        end
    end
    if mod(i,100)==1
        i-1
    end
end


[Y,I]=sort(Bond_index(:,1));
Bond_index=Bond_index(I,:);
Bond_index = unique(Bond_index,'rows','stable');

[Y,I]=sort(Angle_index(:,2));
Angle_index=Angle_index(I,:);
Angle_index = unique(Angle_index,'rows','stable');

overlap_index=overlap_index(1:size(overlap_index,1)/2,:);
% [Y,I]=sort(cell2mat(overlap_index(:,2)));
% overlap_index=overlap_index(I,:);
% overlap_index = unique(overlap_index,'rows','stable');

Bond_index(~any(Bond_index,2),:) = [];
Angle_index(~any(Angle_index,2),:) = [];
% overlap_index(~any(overlap_index,2),:) = [];


nBonds=size(Bond_index,1);
nAngles=size(Angle_index,1);

if nargin > 4 %% This will print a whole lot more info to the calling workspace
    % Set a cutoff vector
    rmax=repmat(max_neigh_distance,nAtoms,1);
    % Reduce the cutoff vector for H - X
    rmax(strncmpi(strtrim(XYZ_labels),'H',1))=1.25;
    for i=1:size(atom,2)
        Neigh_ind=intersect(find(dist_matrix(:,i)>0),find(dist_matrix(:,i)<rmax(i)));%radius_ion([atom.type])));
        Neigh_dist=dist_matrix(Neigh_ind,i);
        atom(i).neigh.type = [atom(Neigh_ind).type]';
        atom(i).neigh.index = Neigh_ind;
        atom(i).neigh.dist = Neigh_dist;
        atom(i).neigh.coords = [[atom(Neigh_ind).x]' [atom(Neigh_ind).y]' [atom(Neigh_ind).z]']; % PBC NOT TAKEN INTO ACCOUNT!!!
        atom(i).bond.type = [];
        atom(i).bond.index = [];
        atom(i).bond.dist = [];
        atom(i).angle.type = [];
        atom(i).angle.index = [];
        atom(i).angle.angle = [];
        atom(i).angle.vec1 = [];
        atom(i).angle.vec2 = [];
        
        if ismember(i,Bond_index(:,1:2))
            [A,B]=find(Bond_index(:,1:2)==i);
            atom(i).bond.type = 1;
            atom(i).bond.index = Bond_index(A,1:2);
            atom(i).bond.dist = Bond_index(A,3);
            if ismember(i,Angle_index(:,1:3))
                %                 [C,D]=find(Angle_index(:,1:3)==i);
                [C,D]=find(Angle_index(:,2)==i);
                atom(i).angle.type = 1;
                atom(i).angle.index = Angle_index(C,1:3);
                atom(i).angle.angle = Angle_index(C,4);
                atom(i).angle.vec1 = Angle_index(C,5:7);
                atom(i).angle.vec2 = Angle_index(C,8:10);
            end
        end
        if mod(i,100)==1
            i-1
        end
    end
    
    %%%%%%%%%%
    
    Atom_labels=unique([atom.type]);
    for i=1:length(Atom_labels)
        label_ind=find(strcmpi([atom.type],Atom_labels(i)));
        Tot_dist=[];Tot_type=[];Tot_index=[];Tot_angleindex=[];Tot_bondindex=[];Tot_neighindex=[];Tot_coords=[];Tot_bonds=[];Tot_angles=[];
        for j=label_ind
            if numel([atom(j).neigh])>0
                Tot_index=[Tot_index; repmat(j,numel([atom(j).neigh.index]),1)];
                Tot_dist=[Tot_dist; [atom(j).neigh.dist]];
                Tot_type=[Tot_type; [atom(j).neigh.type]];
                Tot_neighindex=[Tot_neighindex; [atom(j).neigh.index]];
                Tot_coords=[Tot_coords; [atom(j).neigh.coords]];
            end
            
            if numel([atom(j).bond])>0
                Tot_bondindex=[Tot_bondindex; [atom(j).bond.index]];
                Tot_bonds=[Tot_bonds; [atom(j).bond.dist]];
            end
            if numel([atom(j).angle])>0
                Tot_angleindex=[Tot_angleindex; [atom(j).angle.index]];
                Tot_angles=[Tot_angles; [atom(j).angle.angle]];
            end
        end
        try
            assignin('caller',strcat(char(Atom_labels(i)),'_dist')',[num2cell(Tot_index) num2cell(Tot_neighindex) Tot_type num2cell(Tot_dist)]);
            assignin('caller',strcat(char(Atom_labels(i)),'_coords')',[[atom(Tot_neighindex).x]' [atom(Tot_neighindex).y]' [atom(Tot_neighindex).z]']);
            assignin('caller',strcat(char(Atom_labels(i)),'_bonds')',[Tot_bondindex Tot_bonds]);
            assignin('caller',strcat(char(Atom_labels(i)),'_angles')',[Tot_angleindex Tot_angles]);
            assignin('caller',strcat(char(Atom_labels(i)),'_atom')',atom(ismember([atom.type],Atom_labels(i))));
        catch
            assignin('base',strcat(char(Atom_labels(i)),'_dist')',[num2cell(Tot_index) num2cell(Tot_neighindex) Tot_type num2cell(Tot_dist)]);
            assignin('base',strcat(char(Atom_labels(i)),'_coords')',[[atom(Tot_neighindex).x]' [atom(Tot_neighindex).y]' [atom(Tot_neighindex).z]']);
            assignin('base',strcat(char(Atom_labels(i)),'_bonds')',[Tot_bondindex Tot_bonds]);
            assignin('base',strcat(char(Atom_labels(i)),'_angles')',[Tot_angleindex Tot_angles]);
            assignin('base',strcat(char(Atom_labels(i)),'_atom')',atom(ismember([atom.type],Atom_labels(i))));
        end
    end
end

try
    assignin('caller','dist_matrix',dist_matrix);
    assignin('caller','overlap_index',overlap_index);
    assignin('caller','Bond_index',Bond_index);
    assignin('caller','Angle_index',Angle_index);
    assignin('caller','nBonds',nBonds);
    assignin('caller','nAngles',nAngles);
catch
    assignin('base','dist_matrix',dist_matrix);
    assignin('base','overlap_index',overlap_index);
    assignin('base','Bond_index',Bond_index);
    assignin('base','Angle_index',Angle_index);
    assignin('base','nBonds',nBonds);
    assignin('base','nAngles',nAngles);
end

% toc

##### SOURCE END #####
--></body></html>